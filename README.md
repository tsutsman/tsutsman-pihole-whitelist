# tsutsman-pihole-whitelist

> Англійська версія цього опису доступна у файлі [README.en.md](README.en.md).

Цей репозиторій містить базовий список доменів, які можна додати до білого списку pihole.
Основний список розміщено у файлі `whitelist.txt`. Він включає, зокрема, домени для коректної роботи Microsoft OneDrive.
Нещодавно до списку додано популярні українські сервіси для коректної роботи місцевих сайтів та банків.
Додано підтримку основних сервісів Apple для iCloud та App Store.
Тепер також у списку присутні домени для Google Drive та MEGA, щоб не блокувати роботу цих хмарних сховищ.
Додано хости Synology та популярні сервери точного часу (NTP) для коректної синхронізації часу.
Також додано домени популярних месенджерів, додаткових хмарних сховищ та українських банків.
Окремим розділом тепер додані домени українських державних порталів.

Кожен домен у списках супроводжується коментарем із датою та причиною додавання до whitelist для повної прозорості.

Якщо потрібно швидко зорієнтуватися, які домени додати, щоб не блокувалися легітимні ресурси, перегляньте стислий гайд у [docs/recommended_whitelist.md](docs/recommended_whitelist.md).

## Поточні задачі

Щоб швидко зрозуміти, над чим варто попрацювати далі, скористайтеся беклогом у файлі [docs/pending_tasks.md](docs/pending_tasks.md). Там зібрано пріоритетні напрямки розвитку, поради з тестування та ідеї для розширення інтеграцій.

## Списки за категоріями

Окрім комбінованого файлу `whitelist.txt`, у каталозі `categories/`
розміщено окремі списки за темами. Їх можна імпортувати вибірково,
якщо потрібен лише певний набір доменів.

### Власні категорії

Можна створювати власні файли у каталозі `categories/` або в окремому каталозі й передавати його до скриптів. Назва файлу може бути довільною, головне — використовувати розширення `.txt` та додавати пояснювальні коментарі.

Доступні такі файли:

- `base.txt` — базові домени, що найчастіше використовуються;
- `apple.txt` — адреси сервісів Apple;
- `microsoft_onedrive.txt` — домени Microsoft і OneDrive;
- `ukrainian_services.txt` — популярні українські сервіси та банки;
- `cloud_storage.txt` — хмарні сховища (Google Drive, MEGA, Synology тощо);
- `messengers.txt` — домени Telegram, WhatsApp, Discord;
- `smart_home_devices.txt` — камери Hikvision, Dahua, Yi Home та платформа Tuya;
- `ntp_servers.txt` — сервери точного часу (NTP).
- `gaming.txt` — домени популярних ігор і сервісів (Steam, Epic Games, Riot, Blizzard, Wargaming).
- `web_resources.txt` — CDN та хости скриптів і стилів для вигляду сайтів.
- `office_collaboration.txt` — Zoom, Slack та Microsoft Teams.
- `ai_services.txt` — популярні AI-сервіси.
- `social_networks.txt` — домени популярних соцмереж.
- `streaming_services.txt` — відео- та музичні стрімінги.
- `ecommerce.txt` — міжнародні майданчики електронної торгівлі.
- `educational_resources.txt` — корисні освітні портали.
- `news_media.txt` — популярні новинні ресурси.
- `international_banks.txt` — міжнародні платіжні сервіси.

#### Автоматична перевірка коментарів у категоріях

Для контролю якості додано скрипт `check_category_comments.sh`. Він гарантує, що кожен домен у категоріях має пояснювальний коментар або тимчасово внесений до списку винятків `categories/comment_allowlist.txt`.

```bash
./check_category_comments.sh
```

Якщо у файлі категорії з'являється новий домен без коментаря, перевірка завершиться помилкою і підкаже, який рядок потрібно доповнити. Коли для старих записів коментар ще не додано, зберігайте причину у `comment_allowlist.txt`. Після того як пояснення з'явиться безпосередньо у файлі категорії, відповідний рядок зі списку винятків слід вилучити.

### Вибірковий імпорт та генерація

Кожен файл із каталогу `categories/` можна застосовувати окремо.

- **Через веб-інтерфейс:** у розділі **Whitelist** натисніть **Import** і завантажте потрібний файл, наприклад `categories/apple.txt`.
- **Через командний рядок Linux:**
  - Pi-hole v5:
    ```bash
    xargs -a categories/apple.txt -L1 sudo pihole -w
    ```
  - Pi-hole v6:
    ```bash
    sudo pihole-FTL whitelist add $(cat categories/apple.txt)
    ```

Щоб зібрати власний `whitelist.txt` лише з вибраних файлів чи каталогів, передайте їх до скрипту. Коментарі та дублікати будуть автоматично видалені:

```bash
./generate_whitelist.sh categories/base.txt categories/apple.txt
```

Сформований файл можна імпортувати будь-яким із наведених способів. Якщо ви не працюєте з командним рядком, просто скачайте потрібні файли чи згенерований `whitelist.txt` і додайте їх через веб-інтерфейс.

## Генерація загального списку

Скрипт `generate_whitelist.sh` створює файл `whitelist.txt` з усіх
файлів у каталозі `categories/` або з указаних аргументів. Він
прибирає коментарі та порожні рядки, після чого усуває дублікати.

```bash
./generate_whitelist.sh              # всі категорії
./generate_whitelist.sh categories/cloud_storage.txt extra_dir/  # вибіркові файли чи каталоги
./generate_whitelist.sh -o exports/custom.txt                   # запис у довільний файл
OUTFILE=exports/custom.txt ./generate_whitelist.sh              # альтернатива через змінну середовища
```

Сформований файл одразу готовий до імпорту в pihole. Якщо вказати шлях із підкаталогами, вони будуть створені автоматично.

## Аналітика доменів

Для огляду структури списків використовуйте скрипт `analyze_domains.py`. Він підраховує кількість доменів у кожній категорії,
виявляє дублікати між файлами та формує звіт із розподілом за TLD.

```bash
./analyze_domains.py               # звіт у docs/domain_analysis.md та JSON-версія
DOMAIN_ANALYSIS_OUTPUT=custom.md \
DOMAIN_ANALYSIS_JSON=stats.json \
./analyze_domains.py --stdout     # кастомні шляхи та вивід у консоль
```

Для таблиці «Розподіл за категоріями» можна змінювати логіку сортування:

```bash
./analyze_domains.py --category-sort total                 # сортування за кількістю записів (спадно)
./analyze_domains.py --category-sort unique --category-sort-order asc
DOMAIN_ANALYSIS_CATEGORY_SORT=unique_ratio \
DOMAIN_ANALYSIS_CATEGORY_SORT_ORDER=desc ./analyze_domains.py
```

Підсумки доступні у форматах Markdown (`docs/domain_analysis.md`) та JSON (`docs/domain_analysis.json`), що зручно для
подальшої інтеграції у CI або дашборди.

## Зовнішні джерела доменів

Щоб не шукати вручну додаткові домени для білого списку, скористайтеся
скриптом `fetch_sources.sh`. Він читає перелік джерел із файлу
`sources/default_sources.txt` (або іншого, переданого як аргумент),
завантажує списки доменів і перетворює їх у формати, сумісні з Pi-hole.

```bash
./fetch_sources.sh                     # стандартні джерела
./fetch_sources.sh my_sources.txt      # власний перелік
```

Кожен рядок у файлі джерел має формат `назва|URL|коментар`. Назва
використовується для створення файлу у каталозі `sources/generated/`,
де зберігаються результати. Після успішного запуску додатково
створюється файл `sources/generated/all_sources.txt` із загальним
переліком доменів.

Скрипт `generate_whitelist.sh` автоматично підключає цей файл до
генерації білого списку. Якщо потрібно вимкнути зовнішні джерела або
вказати інше розташування, можна скористатися змінними середовища:

```bash
INCLUDE_EXTERNAL_SOURCES=0 ./generate_whitelist.sh
SOURCES_COMBINED=custom.txt ./generate_whitelist.sh
```

## Використання

1. Скопіюйте файл `whitelist.txt` на сервер з pihole.
2. У веб-інтерфейсі pihole відкрийте розділ **Whitelist** та імпортуйте домени з цього файлу.
3. Або скористайтеся скриптом `apply_whitelist.sh`, який прочитає файл (за замовчуванням `whitelist.txt`) і додасть домени до білого списку:
   ```bash
   ./apply_whitelist.sh
   ./apply_whitelist.sh custom.txt  # інший файл
   ```
4. Для автоматичного додавання можна скористатися API pihole.
   Приклад запиту:
   ```bash
   curl -X POST "http://pi.hole/admin/scripts/pi-hole/php/whitelist.php" \
     -d "addfqdn=example.com" -d "token=ВАШ_ТОКЕН"
   ```
5. У розділі **Adlists** можна додати посилання на сирий файл:
   https://raw.githubusercontent.com/tsutsman/tsutsman-pihole-whitelist/main/whitelist.txt
   Це дозволить pihole автоматично завантажувати оновлення білого списку (див. розділ [«Автоматичне оновлення білого списку»](#автоматичне-оновлення-білого-списку)).

### Приклади для Pi-hole v5 та v6

- **Pi-hole v5**:
  ```bash
  xargs -a whitelist.txt -L1 sudo pihole -w
  ```
- **Pi-hole v6**:
  ```bash
  sudo pihole-FTL whitelist add $(cat whitelist.txt)
  ```

### Інтеграція з Docker-контейнером Pi-hole

Якщо Pi-hole працює у контейнері, список можна оновлювати безпосередньо з хост-системи.

1. Клонуйте репозиторій на хості, з якого керуєте контейнером:
   ```bash
   git clone https://github.com/tsutsman/tsutsman-pihole-whitelist.git /srv/pihole-whitelist
   ```
2. Додайте спільний том до контейнера. Для `docker compose` це може виглядати так:
   ```yaml
   services:
     pihole:
       image: pihole/pihole:latest
       container_name: pihole
       volumes:
         - ./etc-pihole:/etc/pihole
         - ./etc-dnsmasq.d:/etc/dnsmasq.d
         - /srv/pihole-whitelist:/whitelist:ro
   ```
   Том `/srv/pihole-whitelist` буде доступний усередині контейнера як `/whitelist` лише для читання.
3. Згенеруйте потрібний список на хості (можна обмежитись вибраними категоріями):
   ```bash
   cd /srv/pihole-whitelist
   ./generate_whitelist.sh --output exports/docker-whitelist.txt categories/base.txt categories/ukrainian_services.txt
   ```
4. Застосуйте whitelist у контейнері, виконавши скрипт зсередини Pi-hole:
   ```bash
   docker exec -u root pihole bash -lc '/whitelist/apply_whitelist.sh /whitelist/exports/docker-whitelist.txt'
   ```
5. Для автоматизації можна налаштувати cron на хості, який оновлюватиме репозиторій та запускатиме скрипт застосування:
   ```bash
   0 4 * * * cd /srv/pihole-whitelist && git pull --rebase && ./update_and_apply.sh && \
     docker exec -u root pihole bash -lc '/whitelist/apply_whitelist.sh /whitelist/whitelist.txt'
   ```

> **Порада.** Якщо потрібно дозволити запис до каталогу з whitelist усередині контейнера (наприклад, для логів), змініть параметр `:ro` на `:rw` та переконайтеся, що користувач усередині контейнера має права на каталог.

## Автоматичне оновлення білого списку

Список можна підтримувати актуальним двома способами.

1. **Додавання URL до Adlists**  
   Додайте посилання на сирий `whitelist.txt` у розділ **Adlists** веб-інтерфейсу або виконайте команду:
   ```bash
   sudo pihole -a adlist add https://raw.githubusercontent.com/tsutsman/tsutsman-pihole-whitelist/main/whitelist.txt "tsutsman whitelist"
   sudo pihole updateGravity
   ```
   Під час кожного запуску `pihole updateGravity` (зазвичай через вбудований cron) Pi-hole завантажуватиме свіжу версію списку.

2. **Власне cron-завдання**
   За потреби можна налаштувати окремий cron, що періодично запускає `update_and_apply.sh`:
   ```bash
   # щоденний запуск о 03:00
   0 3 * * * /srv/pihole-whitelist/update_and_apply.sh >> /var/log/pihole-whitelist.log 2>&1
   ```
   Скрипт завантажить актуальний `whitelist.txt`, застосує його до Pi-hole та занотує подію в журнал. URL джерела можна змінити через змінну `REPO_URL`, а шлях до журналу — через `LOG_FILE`.

## Перевірка списку

Перед створенням Pull Request запустіть скрипт `check_duplicates.sh`.
Він перевіряє дублікати та доступність доменів за допомогою `host` або `nslookup`.
Можна передати конкретні файли чи каталоги або нічого — тоді скрипт обробить усі списки.

```bash
./check_duplicates.sh categories/ukrainian_services.txt
./check_duplicates.sh whitelist.txt
./check_duplicates.sh                   # перевірити всі списки
```

Скрипт повідомить про дублікати та недоступні домени. Якщо потрібно пропустити DNS-перевірку (наприклад, у середовищі без доступу до мережі), встановіть змінну `SKIP_DNS_CHECK=1`.

Ту саму перевірку виконує GitHub Actions при кожному Pull Request, тож
якщо дублікати з'являться, перевірка завершиться помилкою.
Крім того, щотижня запускається окрема перевірка, що повідомляє про можливі проблеми у списках.

## Очищення недоступних доменів

Скрипт `cleanup_whitelist.sh` регулярно перевіряє домени у каталозі `categories`.
Якщо домен недоступний впродовж кількох запусків поспіль, він переноситься до `categories/deprecated.txt` для подальшого аналізу.
Поведінку можна налаштувати змінними середовища:

- `CATEGORIES_DIR` — шлях до каталогу зі списками (за замовчуванням `categories`);
- `STATE_FILE` — файл для зберігання кількості невдалих перевірок (за замовчуванням `cleanup_state.txt`);
- `THRESHOLD` — скільки разів поспіль домен має бути недоступним, щоб потрапити до `deprecated.txt` (за замовчуванням `3`);
- `DEPRECATED_FILE` — файл, куди додаються вилучені домени (за замовчуванням `categories/deprecated.txt`).

```bash
THRESHOLD=2 ./cleanup_whitelist.sh

# приклад із власним каталогом та журналом
CATEGORIES_DIR=my_lists THRESHOLD=5 LOG_FILE=my.log ./cleanup_whitelist.sh
```

## Експорт у сторонні DNS-рішення

Щоб використати сформований whitelist поза Pi-hole, скористайтеся скриптом
`export_whitelist.sh`. Він підтримує перетворення у формати AdGuard Home та
pfBlockerNG, автоматично пропускає коментарі та порожні рядки і забезпечує
сортування з deduplication.

```bash
# експорт стандартного whitelist.txt у формат AdGuard Home
./export_whitelist.sh --format adguard-home

# робота з власним файлом і кастомним шляхом виводу
./export_whitelist.sh --source exports/custom.txt --format pfblockerng --output exports/custom-pf.txt
```

За замовчуванням результати зберігаються у каталозі `exports/` з назвою на зразок
`whitelist-adguard-home.txt`. Якщо вхідний файл не містить доменів, буде створено
порожній файл, а скрипт виведе попередження у stderr.

## Дорожня карта

Нижче наведено ключові напрями розвитку проєкту на найближчі релізи.

### Наступний крок розвитку

Найближчим завданням є автоматизація генерації індивідуальних списків за категоріями
через веб-інтерфейс. План виконання першого етапу зафіксовано в документі
[`docs/web_interface_plan.md`](docs/web_interface_plan.md), що охоплює:

- вимоги до користувацького сценарію та необхідні опції;
- опис REST-ендпоінта та скрипту `build_whitelist.sh`, який повторно використовує
  наявні інструменти;
- текстовий макет інтерфейсу для інтеграції в панель Pi-hole;
- аналіз впливу на скрипти `generate_whitelist.sh` і `apply_whitelist.sh`.

Після затвердження цього плану можна переходити до наступних пунктів квартальної
дорожньої карти.

### Квартал 1

- Автоматизувати генерацію індивідуальних списків за категоріями через веб-інтерфейс.
- Додати валідацію доменів за допомогою сервісів перевірки репутації.
- Розширити документацію прикладами інтеграції з Docker-контейнерами Pi-hole.

### Квартал 2

- Упровадити підтримку резервного копіювання та відкату списків через CLI.
- Оптимізувати скрипти перевірки доменів для великих списків (понад 50 тис. записів).
- Додати можливість відстеження змін доменів через вебхуки або push-сповіщення.

### Квартал 3

- Впровадити механізм спільного редагування списків з ролями та правами доступу.
- Інтегрувати API для програмного керування білим списком з інших сервісів.
- Запровадити метрики та дашборд для моніторингу стану доменів.

### Квартал 4

- Провести аудит безпеки скриптів та процесів автоматизації.
- Додати локалізацію інтерфейсів та документації щонайменше трьома мовами.
- Підготувати довгострокову стратегію підтримки та оновлень на наступні два роки.

## Як зробити внесок

1. Форкніть репозиторій та створіть окрему гілку.
2. Додайте домени до відповідного файлу у `categories/` і вкажіть дату та причину у коментарі.
3. Запустіть `./check_duplicates.sh` без параметрів, щоб переконатися у відсутності дублювань та недоступних доменів.
4. Згенеруйте оновлений `whitelist.txt` через `./generate_whitelist.sh`.
5. Створіть Pull Request з коротким описом змін.

## Ліцензія

Вміст репозиторію поширюється за умовами MIT License. Деталі в файлі `LICENSE`.

## REST API та веб-форма для вибіркової генерації

Для автоматизації побудови whitelist за категоріями додано прототип REST API `whitelist_builder_api.py`. Він запускає локальний сервер, який переиспользує скрипт `build_whitelist.sh` та надає кілька допоміжних ендпоінтів.

### Запуск сервера
```bash
python3 whitelist_builder_api.py --host 127.0.0.1 --port 5050 \
  --data-dir /tmp/whitelists --log-file /tmp/whitelist_builder.log
```
Основні параметри можна змінювати: `--categories-dir` (каталог з файлами категорій), `--allow-extra-path` (дозволені додаткові каталоги), `--allow-external-categories` (щоб приймати абсолютні шляхи файлів).

Після запуску доступні такі ендпоінти:
- `GET /health` — перевірка стану сервера;
- `GET /api/categories` — перелік категорій із коротким описом і кількістю доменів;
- `POST /api/build` — формування whitelist за вибраними параметрами;
- `GET /downloads/<файл>` — завантаження сформованого файлу.

Приклад запиту до `POST /api/build`:
```bash
curl -X POST http://127.0.0.1:5050/api/build \
  -H 'Content-Type: application/json' \
  -d '{"categories":["base.txt","apple.txt"],"include_external":true}'
```
У відповіді повертається кількість доменів та шлях до згенерованого файла.

### Базова веб-форма
У каталозі `web/` додано сторінку `whitelist_builder.html`, яка взаємодіє з API: завантажує перелік категорій, дає змогу відмітити потрібні та надіслати запит на генерацію. Щоб скористатися інтерфейсом, запустіть веб-сервер (наприклад, `python3 -m http.server` у корені репозиторію) та відкрийте `http://127.0.0.1:8000/web/whitelist_builder.html` у браузері.

Форма відображає опис категорій, параметри зовнішніх джерел і виводить JSON-відповідь API з посиланням на файл.

## Розгортання веб-інтерфейсу Whitelist Builder

Покрокову інструкцію з налаштування API, проксі та статичної сторінки на Pi-hole наведено в документі
[`docs/web_interface_deployment.md`](docs/web_interface_deployment.md). Нижче — стислий огляд ключових етапів.

1. **Підготовка оточення.** Клонуйте репозиторій на Pi-hole, оновіть категорії та зовнішні джерела.
2. **Запуск API.** Запустіть `whitelist_builder_api.py` як сервіс (systemd-юніт у прикладі), вказавши каталог для тимчасових
   файлів і журналу.
3. **Інтеграція з веб-інтерфейсом.** Скопіюйте сторінку `web/whitelist_builder.html` до каталогу веб-адмінки Pi-hole та
   налаштуйте проксі `/api/*` і `/downloads/*` на порт API (за замовчуванням 5050).
4. **Перевірка роботи.** Відкрийте сторінку в браузері, переконайтеся, що відображаються категорії та формується whitelist.

Документ містить готові конфігураційні блоки для `lighttpd`, приклад systemd-юніта й поради щодо оновлення.

## Моніторинг та аналітика

Скрипт `generate_stats_report.sh` формує не лише Markdown-звіт [`docs/data_stats.md`](docs/data_stats.md), а й інтерактивну HTML-панель [`docs/dashboard.html`](docs/dashboard.html). На ній відображаються ключові показники, таблиці категорій та зовнішніх джерел, журнал останніх видалень і графік динаміки кількості доменів.

Панель використовує файл історії [`docs/data_history.json`](docs/data_history.json), який накопичує знімки стану при кожному запуску скрипту. Щоб оновити дані, виконайте:

```bash
./generate_stats_report.sh
```

Готовий `dashboard.html` можна публікувати через GitHub Pages або відкривати локально у браузері. Для інформативного графіка запустіть скрипт кілька разів (наприклад, у cron), щоб `data_history.json` містив хронологію змін.

Для автоматизованих перевірок передбачено режим збереження попередніх міток часу. Він допомагає переконатися, що звіти вже відповідають поточному стану категорій і не потребують оновлення:

```bash
REPORT_TIMESTAMP_MODE=keep \
DASHBOARD_TIMESTAMP_MODE=keep \
REPORT_FOOTER_TIMESTAMP_MODE=keep \
HISTORY_TIMESTAMP_MODE=keep \
./generate_stats_report.sh
```

Саме таку перевірку виконує GitHub Actions у `.github/workflows/ci.yml`: якщо файли `docs/data_stats.md`, `docs/data_stats.en.md`, `docs/dashboard.html` або `docs/data_history.json` змінюються, збірка завершиться помилкою.
